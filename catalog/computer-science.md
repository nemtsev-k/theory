#Computer Science

**Переменные** - это самая важная привязка имён: она устанавливает отношение между именами и значениями. Переменная связывает имя с адресом памяти, где хранится значение, и, таким образом, выступает в качестве его псевдонима. Чаще всего переменная создаётся при помощи оператора присваивания.

**Функция** - поименованный фрагмент программного кода (подпрограмма, к которому можно обратиться из другого места программы).

## Алгоритмы

В программировании **алгоритм** — это набор инструкций для решения конкретной проблемы или достижения конкретной задачи. Основная цель алгоритма — принять входные данные, обработать их и предоставить ожидаемый результат.

**Виды алгоритмов**

* **Алгоритмы сортировки.** Сортировка является фундаментальной операцией в компьютерных науках, и для неё существует несколько эффективных алгоритмов, таких как быстрая сортировка, сортировка слиянием и пирамидальная сортировка.
* **Алгоритмы поиска.** Поиск элемента в большом наборе данных — распространенная задача, и для неё существует несколько эффективных алгоритмов, таких как бинарный поиск и хеш-таблицы.
* **Алгоритмы графов.** Алгоритмы графов используются для решения задач, связанных с графами, таких как поиск кратчайшего пути между двумя узлами или определение связности графа.
* **Динамическое программирование.** Динамическое программирование — это метод решения проблем путем их разбиения на более мелкие подзадачи и сохранения решений этих подзадач во избежание избыточных вычислений.
* **Жадные алгоритмы.** Жадные алгоритмы используются для решения задач оптимизации, делая локально оптимальный выбор на каждом шаге.
* **Разделяй и властвуй.** Разделяй и властвуй — это парадигма разработки алгоритма, основанная на многоветвящейся рекурсии. Алгоритм «разделяй и властвуй» разбивает проблему на подзадачи того же или родственного типа, пока они не станут достаточно простыми, чтобы их можно было решить напрямую.
* **Поиск с возвратом.** Это общий метод нахождения решений задачи, в которой требуется полный перебор всех возможных вариантов в некотором множестве М.
* **Рандомизированный алгоритм.** Рандомизированные алгоритмы используют случайность для решения проблемы. Это может быть полезно для решения проблем, которые не могут быть решены детерминистически, или для повышения средней сложности задачи.

##Структура данных

**Структура данных** — это способ хранения данных в памяти и набор операций, которые она позволяет выполнять.

**Характеристики:**

* Данные в памяти представлены определённым образом, который однозначно позволяет определить структуру.
* Чаще всего внутрь структуры можно добавить элемент или извлечь оттуда. Это свойство не постоянное — бывают структуры, которые нельзя изменять после создания.
* Существуют алгоритмы, которые позволяют взаимодействовать с этой структурой.

Структуру данных для работы выбирают в зависимости от задачи. Если нужно что-то простое, подойдёт обычный массив. Когда требуется создать очередь или историю запросов, выбирают связный список или очередь. Если нужен поиск и сортировка, поможет двоичное дерево.

###Массив (Array)
Одна из самых простых структур данных, которая встречается чаще всего. Именно на массивах основаны многие другие структуры данных: списки, стеки, очереди. Каждый элемент массива имеет индекс. Размер задан заранее — мы точно знаем, сколько в нём индексов.

**Виды**

* **Одномерные** - у каждого элемента только один индекс. Можно представить это как строку с данными, где одного номера достаточно, чтобы чётко определить положение каждой переменной.
* **Многомерные** - у каждого элемента два или больше индексов. По сути, это комбинация из нескольких одномерных массивов, то есть вложенная структура.

**Область применения:**

* В качестве блоков для более сложных структур данных. Массивы предусмотрены в синтаксисе большинства языков программирования, и на их основе удобно строить другие структуры.
* Для хранения несложных данных небольших объёмов.
* Для сортировки данных.

### Динамический массив (Dynamic array)

Это массив у которого размер может изменяться. При его создании задаётся максимальная величина и количество заполненных элементов. При добавлении новых элементов они сначала заполняются до максимальной величины, а при превышении сразу создаётся новый массив, с большей максимальной величиной. Элементы в динамический массив можно добавлять без ограничений и куда угодно. Однако, если добавлять их в середину, остальные придётся сдвигать, что занимает много времени. Поэтому лучше всего динамический массив работает при добавлении элементов в конце.

**Область применения:**

* В качестве блоков для структур данных.
* Для хранения неопределённого количества элементов.

###Связный список (Linked list)

Связный список — это группа из узлов. В каждом узле содержатся:

* Данные.
* Указатель или ссылка на следующий узел.
* В некоторых списках — ещё и ссылка на предыдущий узел.

В итоге получается список, у которого есть чёткая последовательность элементов. При этом сами элементы разрозненны, поскольку хранятся отдельно. Быстро перемещаться между элементами списка помогают указатели.

**Область применения:**

* Для построения более сложных структур данных.
* Для реализации файловых систем.
* Для формирования хэш-таблиц.
* Для выделения памяти в динамических структурах данных.

### Стек (Stack)

Эта структура данных позволяет добавлять и удалять элементы только из начала. Она работает по принципу LIFO — Last In, First Out (англ. «последним пришёл — первым ушёл»). Последний добавленный в стек элемент должен будет покинуть его раньше остальных.

**Область применения:**

* Для реализации рекурсии.
* Для вычислений постфиксных значений.
* Для временного хранения данных, например истории запросов или изменений.

### Очередь (Queue)

Этот вид структуры представляет собой ряд данных, как и стек. Но в отличие от него она работает по принципу FIFO — First In, First Out (англ. «первым пришёл — первым ушёл»). Данные добавляют в конец, а извлекают из начала. Бывают неклассические, двусторонние очереди. В них можно добавлять элементы и извлекать их из начала и конца структуры. Элементы посередине недоступны.

**Область применения:**

* Для реализации очередей, например на доступ к определённому ресурсу.
* Для управления потоками в многопоточных средах.
* Для генерации значений.
* Для создания буферов.

### Множество (Set)

В отличие от предыдущих базовых структур, во множестве данные не упорядочены. Они хранятся группой, их нельзя структурировать и в некоторых случаях нельзя сортировать. Зато с ними можно работать как с классическими математическими множествами: объединять, искать пересечения, вычислять разность и смотреть, является ли одно множество подмножеством другого.

**Область применения:**

* Для поддержания множества уникальных элементов.
* Для хранения данных, которые не нужно сортировать.
* Для сравнения, объединения наборов данных и других операций с ними.

### Карта (Map)

Её ещё называют ассоциативным массивом или словарём. Данные здесь хранятся в паре «ключ/значение», причем каждый ключ уникален, а вот значения могут повторяться. То есть определённому уникальному ключу всегда соответствует конкретное значение.

**Область применения:**

* Для быстрого поиска данных.
* Для создания баз, в которых нужно хранить уникальное соответствие между двумя множествами значений. Их помещают в ключ, и структура проверяет, чтобы ключ не повторялся. Частный случай map — это hash-map, или хэш-таблица. В ней есть ключи и значения, а для их реализации добавляются индексы. Специальная хэш-функция позволяет по ключу вычислить индекс, чтобы найти нужные данные.

### Деревья

Деревья — это иерархическая структура, которая состоит из связанных узлов. Каждый узел дерева содержит данные и ссылки на его дочерние узлы. Вершина дерева называется корнем, узлы у которых нет потомков — листьями.

Деревья помогают организовывать данные иерархически, обрабатывать информацию, искать пути.

### Граф (Graph)

Граф — это более общий случай дерева. Иногда деревья называют ациклическими графами. Отличий у этих структур данных два:

* В графе возможны циклы, то есть «ребёнок» может быть «родителем» для того же элемента.
* Рёбра тоже могут нести смысловую нагрузку, то есть нужно сохранять их значения.

Графы бывают ориентированные и неориентированные. У первых рёбра между узлами имеют направление, так что порядок элементов важен. У вторых направлений нет, и элементы можно читать и обходить в любом порядке.

**Область применения:**

* Для хранения информации, связанной друг с другом сложными соотношениями.
* Для анализа соотносящейся друг с другом информации.
* Для построения маршрута из точки А в точку Б.

## Циклы

**Цикл** — это управляющая конструкция, которая заставляет какой-то блок кода выполняться несколько раз.

Цикл состоит из условия и тела цикла.

Перед запуском цикла проверяется условие. Если условие истинное, то выполняется блок кода, который называется **телом цикла**. Затем этот шаг повторяется. Так будет продолжаться, пока условие не станет ложным. Каждое выполнение тела цикла называется **итерацией**.

###For
Это цикл, который выполняется заданное количество раз
**Структура**

* **Объявление переменной** — это создание итератора, переменной, которая будет изменяться на каждом шаге цикла. Когда итератор достигнет какого-то значения, цикл закончится.
* **Условие** описывает, должен ли цикл продолжаться. Пока оно выполняется, цикл работает. Чаще всего условие — итератор меньше или больше определенного числа. Соответственно, когда итератор достигает указанного значения, цикл останавливается.
* **Действие** — то, что нужно выполнить в конце каждой итерации. Сюда записывают изменения итератора: например, добавить к нему единицу или отнять какое-то число.

**For in / for of / for-each.** Частный случай цикла for — когда нужно пройти по структуре данных. Для этого в некоторых языках существует особая конструкция. Это цикл for, который вместо итератора работает с самой структурой данных, например массивом или объектом.

###While с предусловием
Это цикл, который используют, если нужное количество действий заранее неизвестно. Он может выполниться несколько раз, один раз, бесконечное количество раз — или вообще не выполниться ни разу. Слово while переводится как «пока» и отражает суть: пока верно какое-то условие, цикл выполняется.

###While с постусловием
Это вариация цикла while. Ее единственное отличие — условие пишется не до, а после тела цикла. Условие будет проверяться, когда подпрограмма уже выполнится. А еще такой цикл всегда исполнится как минимум один раз, до проверки условия.

#

**Программист** — человек, который создаёт компьютерные программы, сайты, веб-сервисы и мобильные приложения с помощью языков программирования

**Направления работы**

* Веб-разработка
* Разработка мобильных приложений
* Десктопная разработка

Необходимые качества и навыки разработчика

* **Аналитический склад ума.** Программист должен уметь критически оценивать информацию. Например, судить о полезности фреймворка или технологии не по звёздочкам на GitHub, а проверив производительность и скорость работы через синтетические тесты и бенчмарки. Без базового знания логики трудно разобраться, как выполняется программное обеспечение и как писать простой и легко поддерживаемый код. К тому же специалист, который умеет выстраивать логические связи, может легко выполнять большие задачи, разбивая их на мелкие части.
* **Навык решения проблем.** В коде часто что-то ломается. Умение справляться с трудностями поможет спокойно подойти к отладке кода. Обладая этим навыком, программист может легко преобразовать абстрактные запросы коллег или клиентов в реальные задачи и выполнимые решения.
* **Самоорганизация и тайм-менеджмент.** Многим программистам в самых разных отраслях приходится работать в сжатые сроки, что требует от них чёткого планирования времени, усидчивости и сосредоточенной работы. Но в этой сфере сотрудники часто сталкиваются с перфекционизмом, прокрастинацией и синдромом самозванца.
* **Командная работа и сотрудничество.** В процессе разработки приложения или веб-сайта разные специалисты внутри компании неизбежно будут использовать код, который принадлежит другим командам, или полагаться на него. Чтобы это не затрудняло процесс, программисту нужно уметь сотрудничать с коллегами из разных отделов.
* **Абстрактное мышление.** Иногда уже готовые и реализованные алгоритмы не подходят для проекта и нужно найти новый способ решения проблемы. Научиться мыслить абстрактно сложнее, чем следовать шаблонным решениям, поэтому ценится разработчик, который освоил оба подхода.
* **Гибкость.** Изначально заданные требования могут измениться, например, клиент попросит внести правки и программисту придётся переписывать часть кода. Открытость к изменениям и быстрое включение в новые запросы — важный элемент сотрудничества и командной работы.
* **Инициативность.** Энтузиазм и желание помогать бизнесу зарабатывать с помощью новых решений повышает ценность разработчика и способствует его карьерному росту.

**Разработка** ― это создание программного обеспечения, приложений для смартфонов, сайтов. Разработчики пишут код, который выполняет определённые задачи и делает программу работоспособной. Также они могут заниматься вёрсткой, тестировать и решать проблемы, чтобы гарантировать, что программа работает правильно и соответствует ожиданиям пользователей. Для разработки используют различные языки программирования и инструменты, чтобы создать программное обеспечение, которое поможет пользователю решить его задачи.

#API

API (Application programming interface) — это программный интерфейс приложений, набор инструкций, который позволяет разным приложениям общаться между собой.

**Интерфейс** — совокупность средств, методов и правил взаимодействия между элементами системы.

**Программный интерфейс** - это совокупность методов (функций), которые позволяют взаимодействовать разным элементам системы, не вдаваясь в реализацию этих методов.

**API может быть:**

* У языка программирования, чтобы разные функции правильно взаимодействовали между собой. Каждая функция тут выступает «приложением», а API становится набором инструкций для правильного вызова этих функций.
* У операционной системы, чтобы программы могли извлекать из неё данные и при необходимости изменять настройки ОС. При разработке приложения для Windows, Linux или Android нужно знать API этой системы, чтобы работать с файлами и графикой.
* У веб-сервисов, чтобы другие веб-сервисы и программы могли к ним подключаться и работать совместно.

**Принцип работы API:**

1. Сторонний разработчик пишет какое-то своё приложение, функцию, операционную систему.
2. Он составляет API — набор правил, на основе которых другие разработчики могут использовать его разработку тем или иным способом.
3. Вы получаете этот API — он либо лежит в публичном доступе, либо открывается по запросу для клиентов.
4. Вы вызываете API внутри своего приложения и пользуетесь нужными вам функциями.

**REST API** — определённый набор стандартов по составлению API с помощью протокола HTTP. Этот набор правил позволяет унифицировать программные интерфейсы и сделать их понятными и читабельными.

**OpenAPI** — спецификация, которая формализует написание API и позволяет автоматически генерировать API и интеграции для работы с большим количеством сторонних приложений.

**Docker** — это одновременно платформа и технология для контейнеризации. Она позволяет создавать контейнеры и управлять ими для развёртывания и доставки кода на сервер.

**Контейнер** — это среда, внутри которой имитируется определённая операционная система. В эту систему мы можем положить код и запускать его в конкретной изолированной среде и в определённых нами условиях. Как правило, в одном контейнере запускают одно приложение или даже отдельный его компонент — модуль, функцию или микросервис.

**Преимущества использования контейнеров Docker**

* Возможность отката.
* Готовая среда для запуска.
* Небольшой вес.
* Изолированность от внешней среды.
* Удобные инструменты управления.

##Git

**Система контроля версий** - это программа, которая позволяет хранить разные версии одного и того же документа, легко переключаться между ранними и поздними вариантами, вносить и отслеживать изменения.

Системы контроля версий используют, например, команды разработчиков, так как они часто трудятся над одним проектом, а значит, сразу несколько человек могут изменять один файл одновременно. Система контроля версий помогает таким командам избежать путаницы: она позволяет хранить историю изменений проекта и при необходимости даёт возможность вернуться к предыдущей версии.

Одна из самых популярных систем контроля версий называется Git.

**Определения**

**Репозиторий** — каталог файловой системы, в котором находятся: файлы конфигурации, файлы журналов операций, выполняемых над репозиторием, индекс расположения файлов и хранилище, содержащее сами контролируемые файлы.

**Рабочая область** — это файлы и папки в корне проекта, то есть тот код с которым вы работаете.

**Хранилище** — это содержимое скрытой папки .git, которая добавляется в проект при инициализации. В этой папке хранятся все версии рабочей области и служебная информация.

**Индекс** — список файлов, изменения в которых попадут в коммит.

**Коммит** — это сохранение текущего состояния проекта. Каждый коммит — это отдельная версия проекта, которая сохраняется и добавляется в хранилище.

**Ветка** -

**Форк** - ваша персональная версия мастер-репозитория.

**Пулреквест** — это предложение изменить код в репозитории. После создания пулреквест должен получить ревью и одобрение так называемого коллаборатора — пользователя GitHub, который имеет права администратора в мастер-репозитории.

**В итоге проект работает так:**

1. Репозиторий хранит все версии проекта. В случае передачи этого проекта другому человеку, он увидит всё, что с ним происходило до этого.
2. Ничего не теряется и не удаляется бесследно. При удалении файла в новой версии добавляется запись о том, что файл был удалён.
3. Всегда можно вернуться к любой из версий проекта, загрузив её из хранилища в рабочую область.

Варианты взаимодействия с Git

* **Терминал** У системы Git отсутствует графическая версия. Поэтому работа с Git ведётся через командную строку. В разных операционных системах свои программы для взаимодействия с Git. В мире разработки такие программы называют «терминал» или «консоль». А работает это так: мы вводим команду и получаем реакцию машины: сообщение об ошибке, запрос на подтверждение информации, результат выполненных действий.
* **GUI** Облегчить работу с Git могут специальные программы. Такие программы в удобной форме показывают изменения в коде, список коммитов и обладают другими удобными возможностями. Обычно в подобных программах есть возможность выполнять стандартные Git команды, просто нажав на кнопку.
* **GitHub** — это веб-сервис, который основан на системе Git. Это такая социальная сеть для разработчиков, которая помогает удобно вести коллективную разработку IT-проектов. Здесь можно публиковать и редактировать свой код, комментировать чужие наработки, следить за новостями других пользователей.

git config --global user.name "ваше имя"
git config --global user.email "ваш email"

Проверить, что настройки сохранились, можно при помощи команды:
git config --list

индексация всех изменённых файлов
git add .

просмотр всех проиндексированных файлов
git status

Чтобы Git сохранил проиндексированные файлы, их нужно закоммитить, то есть зафиксировать все сохранённые изменения и дать им название.
git commit -m "ваше сообщение"

Как часто стоит делать коммиты? Всегда, когда состояние обрело законченный вид. Например, вы добавили новый блок или исправили ошибку, или просто сделали изменения, которые боитесь потерять. Помните: коммит — это просто сохранение.

**SSH** — это протокол для безопасного соединения между компьютерами. Его используют не только для Git. Например, через SSH системные администраторы управляют серверами.

Каждый SSH-ключ состоит из пары: открытый (публичный) и закрытый (приватный) ключ. Открытый ключ отправляется на сервер, его можно не прятать от всех и не переживать, что кто-то его увидит и украдёт. Он бесполезен без своей пары — закрытого ключа. А вот закрытый ключ — секретная часть. Доступ к нему должен быть только у вас.

Генерируем пару ключей командой:
ssh-keygen -t ed25519 -C your_mail@example.com

убедимся, что связь с GitHub установлена. Для этого введём в терминале:
ssh -T git@github.com

копирование репозитория в компьютер
git clone git@github.com:your-nickname/your-project.git

Посмотреть историю коммитов
git log --oneline

список веток
git branch

создать новую ветку
git checkout -b имя-новой-ветки

переключение ветки
git checkout

origin — имя удалённого репозитория, который был склонирован на компьютер (ваш форк)

Отправить в репозиторий новый коммит
git push origin module1-task1

Добавить ссылку на мастер-репозиторий. alias - любое имя
git remote add alias git@github.com:your-repo.git

Забрать изменения из ветки master мастер-репозитория
git pull academy master

**Конфликт** - это событие, когда один и тот же файл в одном и том же месте, но в разных ветках, менялся по-разному.

удалить файл из индекса, но оставить на диске
git rm --cached имя-файла

Как исправить сообщение последнего коммита
git commit --amend -m "Правильное сообщение коммита"

rebase, cherry-pick, squash, bisect

Сайты использующие репозитории Git

* GitHub
* Bitbucket
* GitVerse

## Парадигмы программирования

### Императивное программирование

Императивный стиль смешивает назначение программы и детали её реализации. Если вам нужно детально описать какое-то действие — например при разработке конкретного алгоритма — то больше подходит императивный подход.

#### Процедурное программирование

Это парадигма, в которой последовательные команды собираются в подпрограммы. Между собой эти подпрограммы общаются через общую память.

#### Объектно-ориентированное программирование

**ООП** (объектно-ориентированное программирование) — парадигма, в которой сущности в программе представляются в виде объектов. Каждый объект — экземпляр какого-то класса, некой абстрактной сущности, в которой описано поведение.

**Аспекты**

* **Абстракцией** — выделением таких характеристик объекта, которые достаточно точно описывают его поведение, но не вдаются в детали;
* **Инкапсуляцией** — размещением данных внутри того объекта, который их использует;
* **Полиморфизмом** — умением работать с разными типами объектов или данных;
* **Наследованием** — умением объекта «забирать по наследству» свойства или характеристики от объектов-родителей.

###Декларативное программирование

Декларативный стиль старается описывать только назначение. Если вы работаете на уровне бизнес-логики, то лучше писать декларативно, а детали реализации скрыть в более низком уровне абстракций.

#### Логическое программирование

Его суть заключается в том, чтобы, используя математические доказательства и законы логики, решать бизнес-задачи. Чтобы использовать логическое программирование, необходимо уметь переводить любую задачу на язык математики. Логическое программирование часто используется для моделирования процессов.

#### Функциональное программирование

В этой парадигме понятие функции близко к математическому понятию функции. Особенность функции в этой парадигме в том, что она должна быть чистой, то есть должна зависеть только от аргументов и не может иметь никаких побочных эффектов. Побочный эффект — это какое-либо изменение внешней среды. Если функция меняет глобальную переменную или, например, вызывает метод внешнего объекта, то она меняет внешнюю среду.

Выбор парадигмы зависит от многих факторов: договорённости, язык программирования, привычки и прочее. Но один из таких факторов — удобство решения задачи.

Если очевидно, что задачу можно решить одной функцией, то нет необходимости городить ООП-шный зоопарк. И так же нет смысла отказываться от плюсов ФП, если нам нужно работать с побочными эффектами.

## Объектно-ориентированное программирование

## Функциональное программирование

## Реактивное программирование

**Реактивность** – это способ автоматически обновлять систему в зависимости от изменения потока данных.

**Поток данных** – любая последовательность событий из любого источника, упорядоченная во времени.

**Реактивное программирование** – парадигма в программировании, в которой программа больше сосредоточена на управлении потоками данных, таким образом описывая взаимосвязи между ними.

Реактивное программирование помогает абстрагироваться от описания действий в коде напрямую и сосредоточиться на взаимосвязи данных. Оно создано, чтобы упростить создание программ с большим количеством связей.

Само по себе реактивное программирование редко встречается в чистом виде. Часто оно объединено с другими парадигмами. Так появились такие смешения, как императивное реактивное программирование, объектно-ориентированное реактивное программирование и функциональное реактивное программирование.

#### Типы реактивности

* **Push-реактивность.** Когда в реактивной системе по методу push происходит изменение, она самостоятельно проталкивает (от англ. push – «толкать») это изменение всем подписчикам. При таком типе реактивности все подписчики будут получать актуальные изменения сразу, как только они произошли.
* **Pull реактивность.** Вычисления, вызванные изменением данных в источнике, здесь откладываются до тех пор, пока не будут нужны. При таком типе реактивности подписчики вытянут (от англ. «pull» – тянуть) новые данные, только когда обновится вся система.

## REST API

## RPC

## GraphQL

## Базовое понимание сложности

## Алгоритмы

## Чистый код

## Архитектура

**Архитектура приложения** — это набор решений о том, как модули приложения будут общаться друг с другом и с внешним миром. Архитектура помогает решать задачи проектирования сложных систем.

**Архитектура** — это совокупность важнейших решений (паттернов, технологий, парадигм) об организации программы.

Основные цели принципов, применяемых в архитектуре, состоят в том, чтобы сделать код:

* **Поддерживаемым** — легко добавлять новые возможности в уже разработанный сайт и развивать существующие.
* **Понятным** — код понятен участникам команды и новым разработчикам, знакомым с архитектурой.
* **Переиспользуемым** — уже готовые в проекте решения могут быть переиспользованы для решения новых задач.
* **Лёгким в отладке** — можно относительно легко и быстро находить ошибки в коде и править их.

Определяясь с архитектурой приложения, изначально нужно ответить на следующие вопросы:

* Из каких частей состоит наше приложение?
* Как различные части общаются друг с другом?
* Как части приложения зависят друг от друга?

Принципы архитектуры современного сайта:

1. **Модульность.** Современные сайты огромны. Разрабатывать их как единое целое, держа в голове всю функциональность, попросту невозможно. Поэтому их обычно делят на составные части — модули. Каждый из них можно разрабатывать по отдельности, абстрагируясь от остального функционала ресурса, сосредотачиваясь на возможностях самого модуля. Каждый модуль в определённой степени независим и отвечает за свою функциональность.
2. **Правила управления данными.** Одна из ключевых задач Frontend-разработчика — это преобразование данных в интерфейс пользователя. Поэтому важно иметь правила, позволяющие просто и понятно работать с данными, легко находить ошибки, связанные с потерей данных или другими особенностями.
3. **Простота.** Современные приложения достаточно сложны. Но грамотная архитектура за счёт принципов, повторяющихся решений и ограничений делает код таких приложений более простым для понимания.
4. **Расширяемость.** Продуктовое приложение — это не статичный код, зависший во времени, это живой организм. В код постоянно требуется вносить изменения, добавляя новые фичи и улучшая уже имеющийся функционал. Легко расширяемым называют такое приложение, которое позволяет добавлять новые возможности и модули без значительных изменений в существующем коде.

### Паттерны

**Паттерн проектирования** — шаблонное решение частой архитектурной проблемы.

MV*-паттерны (Модель-Представление-*) хорошо подходят для одностраничных приложений. Такие паттерны решают задачи по взаимодействию пользовательского интерфейса и участков кода, которые работают с данными приложения.

Наиболее популярными MV-паттернами являются:

* MVC — «Модель-Представление-Контроллер»;
* MVP — «Модель-Представление-Презентер»;
* MVVM — «Модель-Представление-Модель представления».

Главная цель MV*-паттернов — разделить отображение и логику интерфейса, а также получение и обработку данных.

* **Порождающие паттерны** помогают решать задачи с созданием сущностей или групп похожих сущностей. Они убирают лишнее дублирование, делают процесс создания объектов короче и прямолинейнее.
  * Фабрика;
  * Фабричный метод;
  * Абстрактная фабрика;
  * Строитель.
* **Структурные паттерны** помогают решать задачи по совмещению и сочетанию сущностей. Они заботятся о том, как сущности могут использовать друг друга.
  * Адаптер;
  * Декоратор;
  * Фасад;
  * Прокси.
* **Поведенческие паттерны** распределяют ответственность между модулями и определяют, как именно будет происходить общение.
  * Цепочку ответственности;
  * Стратегию;
  * Команду;
  * Наблюдателя.

## Проектирование



**TSV** (tab-separated values) — это текстовый формат файла, в котором данные в столбцах разделены знаками табуляции, а строки — знаками перевода строки. Удобно работать с TSV-файлами в редакторах электронных таблиц. 
