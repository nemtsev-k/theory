# Тестирование

**Тестирование** — важная часть процесса разработки. Тестирование помогает удостовериться, что части приложения выглядят и работают так, как описано в техническом задании.
Правильный подход к тестированию в долгосрочной перспективе сокращает время разработки, и улучшает качество кода разрабатываемого приложения.

**Виды:**

* **Ручное тестирование** предполагает участие человека. Он (разработчик или тестировщик) должен вручную проверить работоспособность и функциональность приложения. Например кроссбраузерное тестирование вёрстки. Во время работы разработчики открывают несколько браузеров, в том числе мобильные, чтобы убедиться в корректном отображении интерфейса приложения. Другим примером ручного тестирования служит проверка тестировщиком пользовательских сценариев.
* **Автоматизированное тестирование** — это тестирование с использованием инструментов, которые самостоятельно выполняют действия на основе написанных сценариев. Такое тестирование проходит без участия людей. Его могут запускать разработчики самостоятельно или переложить эту функции на CI/CD (система непрерывной интеграции). Сценарии автоматизированного тестирования принято называть автотестами. Автоматизированный тест — ни что иное как дополнительная программа (программный код). Чтобы проверить отдельную функцию или часть приложения нам требуется написать подпрограмму, которая сможет это сделать вместо нас. Код для автотестов мы должны писать на всю функциональность или функции, которые требуется тестировать.

**Виды автоматизированного тестирования**

* **Низкоуровневым тестированием** как правило занимаются разработчики (путём написания тестов). Низкоуровневое тестирование призвано протестировать код на уровне отдельных функций.
* **Высокоуровневое тестирование** нередко осуществляется тестировщиками. Такое разделение логично, хотя и не обязательно. Высокоуровневое тестирование призвано имитировать действия пользователя.

**Преимущества автоматизированного тестирования**

* **Нахождение ошибок на этапе разработки.** Когда тесты пишутся параллельно логике программы или даже до того, как она реализована, разработчикам намного легче понять, что работает, а что — нет.
* **Повышение качества кода.** Подход к разработке с обязательным этапом написания тестов самими разработчиками помогает структурировать логику выполнения функций или частей приложения до написания кода. Это заставляет разработчиков больше задумываться над вопросом: «А все ли учтено в этой функции?».
* **Живая документация проекта.** Сценарии тестирования, воплощённые в код, становятся документацией проекта. Притом что тесты меняются вместе с основной кодовой базой проекта, они являются самыми актуальными спецификациями приложения.
* **Сокращение времени тестирования.** Автотесты позволяют систематически тестировать приложение или отдельные его части, сокращая время на ручное тестирование. Чем больше тестов вы напишите, тем серьёзней сократится время ручного тестирования.
* **Повышение качества тестирования.** Благодаря автотестам можно уменьшить влияние «человеческой ошибки» на процесс тестирования. К счастью, автотесты не пропустят шаги, потому что «они устали», «отвлеклись» или «просто не обратили внимание». Процесс тестирования с использованием автотестов можно проводить без участия человека.
* **Управляемая регрессия приложения.** Если разрабатываемое приложение большое, любое ручное тестирование всех его частей начинает занимать огромное количество времени и человеческих ресурсов. Возможность в любой момент провести тестирование сокращает время на обратную связь в стиле «а сломали ли мы что-нибудь, когда делали новую фичу» или удостовериться в том, что рефакторинг ничего не поменял с точки зрения пользователя.

**Недостаток автоматизированного тестирования**

* **Дополнительная кодовая база с тестами.** Это дополнительный код. Его необходимо поддерживать и рефакторить в соответствии с изменившимися требованиями. Чем больше приложение, и чем больше частей в нем покрыто тестами, тем больше времени будет уходить на поддержку их актуальности.

Автоматизировать можно многое, но не всё. Ручное тестирование в любом случае должно оставаться частью процесса работы над проектом.

#### Виды автотетов

* **Смоук-тесты** (англ. smoke testing — дымовые тесты) — это набор чек-листов, которые определяют базовую работоспособность приложения или сайта.

**Юнит-тестирование (модульное тестирование)**
Юнит (англ. unit — модуль) тестирование — самая низкоуровневая категория тестов, которые пишут разработчики. Это тесты на уровне отдельных функций в коде. Юнит-тесты специфичные и узкоспециализированые. Ничего страшного, если при изменении тестируемой функции приходится переписывать юнит-тесты. Примером юнит-тестов могут служить автотесты для функции сортировки массива данных по заданному параметру.

Итак, главная задача юнит-тестов заключается в проверке логики в отдельных участках кода (функциях, модулях и так далее).

**Интеграционное тестирование**
Для тестирования правильного взаимодействия компонентов между собой пишут интеграционные тесты. В отличие от юнит-тестирования, в котором важна максимальная изоляция кода, в интеграционном тестировании важно протестировать, как несколько компонентов или частей системы будут вести себя при совместном или последовательном вызове.

Примером интеграционного тестирования могут быть автотесты проверки правильной работы компонента формы регистрации и модуля-хранилища данных с обращением к базе данных.

**Системное тестирование**
Системные тесты направлены на тестирование части приложения, или всего приложения в целом. Такие тесты представляют собой обширный набор интеграционных автотестов, объединенных в сценарии.
Системные автотесты — позволяют проверить целостность архитектуры системы и ее поведения в определенных ситуациях, а не тестирование взаимодействия отдельных частей приложения. Примером системного тестирования может быть проверка производительности приложения при большом количестве одновременных посетителей, или другими словами, нагрузочное тестирование.

**Тестирование кода с внешними зависимостями**

**Моки** — это объекты с методами или отдельные методы, которые при их вызове ведут себя так, как требуется для тестирования определенной функции. Как правило, они не несут в себе сложной логики, а всего лишь имитируют вызов другой функции, которую не нужно тестировать в этом автотесте.

**Стабы** — это объекты, которые имитируют структуры данных. Их цель абсолютно такая же, как и у имитаций, с той лишь разницей, что это просто данные.

Если тестируемый метод сортировки массива внутри себя вызывает метод получения данных из компонента-хранилища, то упомянутый компонент и его метод можно «замокать» на возвращение данных, которые требуются в этом конкретном тесте. Таким образом будет протестирована только часть кода, которая сортирует данные. Ведь компонент-хранилище может внутри себя вызывать обращение к базе данных, что не нужно проверять при юнит-тестировании. В приведённом примере метод возвращения данных является имитацией (моком), а вот возвращаемые им «не настоящие» данные — заглушкой (стабом).

**Подходы к автоматическому тестированию**

* **Разработка через тестирование.** Методика написания тестов до написания кода называется TDD (Test Driven Development). Допустим, необходимо реализовать функцию сортировки данных. По методологии TDD, сначала необходимо написать тесты на код, который будет имплементирован. Только после этого начинается программирование исполняемой функции. При внесении изменений в существующую функцию также сначала исправляются тесты, а только затем меняется код функции. TDD принуждает разработчиков думать о возможных сценариях до того, как что-то будет написано. Это в свою очередь позволяет найти неточности или ошибки в документации и требованиях к задаче на этапе ее реализации, а не при ее тестировании или даже на более поздних этапах.

* **Тесты после.** Этот подход называется TLD (Test-Last Development). Сначала мы пишем код (например, функцию сортировки), а затем покрываем его тестами.

**Какой подход выбрать**
Оба подхода имеют свои достоинства и недостатки. Объективно, подход TDD имеет больше плюсов. Разрабатывая через тестирование удаётся предусмотреть больше пограничных ситуаций и лучше понять, как действительно должна работать проверяемая функция. Более того, когда мы применяем подход TDD, то сразу делаем задел на написание тестируемого кода. Не всякий код может быть протестирован. Вы это увидите на практике. Порой, чтобы покрыть код тестами требуется произвести рефакторинг. Методология TDD борется с этой проблемой на ранней стадии.

**Assert** — стиль проверки выражений — подразумевает под собой наличие эталона для последующего сравнения. На практике это выглядит так: assert принимает на вход значение, которое переводится в boolean. Если значение равно true, продолжается выполнение, а false останавливается.

**Jest** — универсальный фреймворк для тестирования JavaScript. Он позволяет тестировать проекты, использующие React, TypeScript, Node.js, Angular, Vue и другие технологии. Изучив один инструмент, вы сможете применять его с разными технологиями.

**Преимущества Jest**

* **Не требует длительной настройки.** Jest спроектирован так, что работает из коробки для большинства проектов на JavaScript.
* Хорошо документирован. Документация Jest доступна на нескольких языках, в том числе на русском.
* **Богатое API для тестов.** Jest из коробки имеет большой набор методов для тестирования. Не требуется никаких дополнительных библиотек.
* **Параллельное выполнение тестов.** Тесты на Jest изолированы друг от друга и запускаются параллельно, что сокращает время их выполнения.
* **Показывает покрытие кода тестами из коробки.** Удобно отслеживать, какие части кода покрыты автотестами, вплоть до ветвлений в условных и тернарных операторах.

## Базовое умение тестировать

## Unit-тестирование

## e2e тестирование

## Интеграционное тестирование

## Скриншотное тестирование

## Снепшотное тестирование

## Скоростное тестирование

## Бандл тестирование

## Нагрузочное тестирование для SSR

## Базовое понимание как работает CI

## Умение запускать Docker

## Умение писать Dockerfile

## Умение описывать свои action для CI pipeline

## Умение строить свой pipeline

## Понимание в каком продакшен окружении работает

## Решение сложных задач тестирования

## DevOps

**В любом процессе разработки участвует три команды:**
*Dev — программисты, которые непосредственно пишут код;
*QA/QC — тестировщики, которые выявляют ошибки в коде, вручную или автоматически;
*Ops — инженеры, которые поддерживают инфраструктуру для написания кода, например сервера, а также берут уже рабочий код и запускают на реальные сервера, чтобы клиент получил доступ к сайту, сервису или приложению.

**Методология DevOps — это комбинация из двух факторов:**
*особой философии, принципов работы DevOps: налаженного общения между командами, совместных KPI, общей ответственности за результат;
*набора инструментов, который позволяет создать этот самый конвейер: автоматических систем тестирования, инфраструктуры для написания и развёртывания кода, программ для передачи кода между разными командами.

**Как устроена методология DevOps**
Создание любого сервиса состоит из трёх процессов: разработки, тестирования и развёртывания на «боевых» серверах, доступных клиенту. При классическом подходе эти процессы идут последовательно, один за другим. При подходе DevOps всё происходит параллельно:

*Инженеры по эксплуатации создают среду для разработки: пишут инструменты для автоматизации, настраивают тестировочные сервера, поддерживают пространство для работы разработчиков и тестировщиков в рабочем состоянии.
*Разработчики пишут код, и он сразу уходит на тестирование. Часть тестов проводится автоматически, самые сложные вручную делает команда тестировщиков.
*Код с исправленными ошибками автоматически уходит к инженерам для запуска на боевых серверах. При этом в тот же момент уже разрабатываются новые функции приложения.
*Служба эксплуатации с помощью ручных и автоматических систем мониторинга в режиме реального времени видит проблемы и ошибки кода на боевых серверах. При необходимости код сразу возвращают разработчикам на доработку.

Такой параллельный подход к работе позволяет практически мгновенно разрабатывать важные обновления для приложений, исправлять ошибки, не прекращая основные работы, и выпускать продукты гораздо быстрее.

**Инструменты DevOps**

* **Системы контроля версий.** Обычно используют Git. Это среда, в которую вносят код в процессе написания и разработки. В ней можно видеть все внесённые изменения, быстро откатить приложение к предыдущей конфигурации и сливать вместе разные версии кода, если над одной и той же функцией работает несколько программистов.
* **CI/CD-системы.** CI/CD — это комбинация непрерывной интеграции и непрерывного развёртывания контента. В этом и есть суть подхода DevOps, при котором все процессы происходят параллельно. Чтобы обеспечить автоматическую передачу кода, нужны CI/CD-системы, например GitLab или Jenkins. Они позволяют настраивать скрипты и сразу получать обратную связь на переданный дальше по конвейеру код.
* **Системы мониторинга.** Они автоматически проверяют сервера и приложения, собирают логи с ошибками, отправляют сообщения о проблемах. Обычно это комплексные приложения типа Grafana и Prometheus.

**Плюсы использования DevOps**

* Быстрый выпуск новых приложений и функций.
* Возможность чаще выпускать обновления и исправления
* Ниже стоимость разработки

Недостатки DevOps

* Дороговизна для небольших компаний.
* Неправильное понимание принципов DevOps
