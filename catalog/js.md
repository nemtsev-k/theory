
Front-end (фронтенд)
1. область технологий для разработки веб-интерфейсов, включает вспомогательные инструменты и технологии работающие в браузере или клиентсайд.
1. внешняя часть серверной системы, отвечающая за приём данных, отправку ответов и генерацию кода для браузера, входит в серверсайд.

Back-end (бэкэнд)
1. Область веб-технологий, работающих на сервере.
1. Внутренняя часть серверной системы, занимается обработкой данных.

Fullstack (фулстек)
1. Область специализации, которая включает в себя фронтенд и бэкэнд.
1. специалист, который может отвечать за все аспекты проекта: от клиентской до серверной части.

Переменные - это самая важная привязка имён: она устанавливает отношение между именами и значениями. Переменная связывает имя с адресом памяти, где хранится значение, и, таким образом, выступает в качестве его псевдонима. Чаще всего переменная создаётся при помощи оператора присвваивания.

Функция - поименованный фрагмент программного кода (подпрограмма, к которому можно обратиться из другого места программы).

Web-site (сайт) - объединённые под одним адресом страницы.






# Информация

## JavaScript

Интерфейс - это набор всех свойств и элементов.

Первый принцип ООП заключается в том, что у каждого объекта есть чёткий фиксированный интерфейс.

**Инкапсуляция**
* объект должен быть чёрным ящиком.
* разработчик взаимодействует с объектом через публичный интерфейс.
* нельзя вторгаться во внутренние механизмы класса снаружи (при переопределении - можно).

**Наследование** - это один из способов использовать методы и свойства одних объектов (родителей) в других объектах (потомках).

**Датабиндинг** (связывание данных) - это связь между пользовательским интерфейсом пользователя и бизнес-логикой.

Датабиндинг прекрасен тем, что при правильной настройке связей мы изменить данные, а разметка изменится самостоятельно следом за ними.

**Бизнес-логика** - правила и ограничения реального мира, которые описываются с помощью компьютерной программы.

**Иммутабельность** - неизменяемость, когда какие-то данные нельзя изменить, можно только записать на их место другие.

**Иммутабельность** - это механизм контроля над тем, какие части кода могут произвести изменения значения.

## Node.js
Во фронтенде для сборки обычно применяется среда Node.js.

Node.js — это кросс-платформенная среда выполнения JavaScript с открытым исходным кодом.

npm (Node Package Manager) — менеджер пакетов для JavaScript, входящий в состав Node.js.

Npm позволяет разработчикам по всему миру загружать свои решения популярных задач в виде отдельных модулей — JavaScript-пакетов. Другие разработчики могут получить эти пакеты через npm и использовать в своём проекте. Npm-пакеты особенно актуальны при сборке проекта. Большинство проблем при решении этой задачи — типовые, хоть и сложные. Они повторяются из проекта в проект, поэтому их уже неоднократно решало множество разработчиков. И вместо того, чтобы писать собственный код, проще взять готовый модуль.

**Сборщики модулей**
* Webpack
* Esvuild
* Pollup
* Vite
* Parcel


**Полифил** — это код, который реализует новую функциональность с помощью уже имеющихся в языке конструкций. Например, если мы имеем дело с очень старым браузером, который не поддерживает метод массива map, то можно написать собственный, делающий то же самое, и «прикрутить» его к глобальному объекту Array. Таким образом с помощью полифилов можно имитировать многие новые функции языка. Но не все. Если новый стандарт не просто добавляет какую-то функциональность, а вводит новый синтаксис, простых полифилов не хватит. Ведь, встретив незнакомую конструкцию, браузер выбросит ошибку, и код сломается. Так что в этом случае нужно средство помощнее — транспиляция.

Термин «транспиляция» составлен из двух частей: трансформации и компиляции. И это в общих чертах описывает то, что при ней происходит. Программы-транспиляторы берут один «диалект» языка, например ECMAScript 2022, и преобразуют его в другой, например ECMAScript 5. 

**Babel** — это транспилятор, способный преобразовывать различные расширения синтаксиса JavaScript в обычный JavaScript, а также трансформировать конструкции из современного стандарта в более старые стандарты.

## Архитектура
Архитектура — это совокупность важнейших решений (паттернов, технологий, парадигм) об организации программы.

Основные цели принципов, применяемых в архитектуре, состоят в том, чтобы сделать код:
* **Поддерживаемым** — легко добавлять новые возможности в уже разработанный сайт и развивать существующие.
* **Понятным** — код понятен участникам команды и новым разработчикам, знакомым с архитектурой.
* **Переиспользуемым** — уже готовые в проекте решения могут быть переиспользованы для решения новых задач.
* **Лёгким в отладке** — можно относительно легко и быстро находить ошибки в коде и править их.

Определяясь с архитектурой приложения, изначально нужно ответить на следующие вопросы:
* Из каких частей состоит наше приложение?
* Как различные части общаются друг с другом?
* Как части приложения зависят друг от друга?

Принципы архитектуры современного сайта:
1. Модульность. Современные сайты огромны. Разрабатывать их как единое целое, держа в голове всю функциональность, попросту невозможно. Поэтому их обычно делят на составные части — модули. Каждый из них можно разрабатывать по отдельности, абстрагируясь от остального функционала ресурса, сосредотачиваясь на возможностях самого модуля. Каждый модуль в определённой степени независим и отвечает за свою функциональность.\
Модульность характерна не только для разработки ПО, но и в целом для сложных инженерных задач. Например, инженеры не строят с ходу сам автомобиль, вместо этого сложный предмет обычно разбивают на более простые модули: кузов, двигатель, колёсная база и так далее. И уже из этих хорошо продуманных и протестированных модулей, словно из конструктора, собирают автомобиль.
1. **Правила управления данными.** Одна из ключевых задач Frontend-разработчика — это преобразование данных в интерфейс пользователя. Поэтому важно иметь правила, позволяющие просто и понятно работать с данными, легко находить ошибки, связанные с потерей данных или другими особенностями.
1. **Простота.** Современные приложения достаточно сложны. Но грамотная архитектура за счёт принципов, повторяющихся решений и ограничений делает код таких приложений более простым для понимания.
1. **Расширяемость.** Продуктовое приложение — это не статичный код, зависший во времени, это живой организм. В код постоянно требуется вносить изменения, добавляя новые фичи и улучшая уже имеющийся функционал. Легко расширяемым называют такое приложение, которое позволяет добавлять новые возможности и модули без значительных изменений в существующем коде.

## Паттерны
Паттерн — это образец или шаблон. А в программировании паттернами называют проверенные подходы или алгоритмы для решения часто встречающейся проблемы.

MV*-паттерны (Модель-Представление-*) хорошо подходят для одностраничных приложений. Такие паттерны решают задачи по взаимодействию пользовательского интерфейса и участков кода, которые работают с данными приложения.

Наиболее популярными MV-паттернами являются:
* MVC — «Модель-Представление-Контроллер»;
* MVP — «Модель-Представление-Презентер»;
* MVVM — «Модель-Представление-Модель представления».

Главная цель MV*-паттернов — разделить отображение и логику интерфейса, а также получение и обработку данных.

## Веб-приложения
В основе любого веб-приложения три компонента: HTML (структура интерфейса), CSS (оформление) и JavaScript (поведение).

* Multi Page Application (MPA) — это приложения, которые состоят из нескольких HTML-страниц. Главная особенность MPA — полная перезагрузка страницы при переходе между разными страницами приложения. Каждая страница предоставляет определённую функциональность веб-приложения.
* Single Page Application (SPA) — это веб-приложение, которое работает в рамках одной HTML-страницы. Кклиент загружает её со всеми ресурсами один раз при первом посещении приложения. Все дальнейшие действия пользователя происходят без перезагрузки страницы.
* Progressive Web Application (PWA) - веб-приложение сочетающее преимущества обычных сайтов и нативных приложений: быстрая загрузка, установка в ОС, работа в офлайне, пуш-уведомления, доступ к системным API.
* Server-Side Rendering (SSR) — в этом веб-приложении за подготовку HTML-кода отвечает сервер. Страница генерируется каждый раз при очередном обращении клиента. Клиенту отправляется готовый HTML, стили и при необходимости JavaScript. С точки зрения клиента, это мало чем отличается от MPA. SSR приложения хорошо подходят для SEO. Но может возрастать нагрузка на сервер, так на каждый запрос клиента приходится заново генерировать страницы.
* Static Site Generator (SSG) - в этом веб-приложении статический HTML формируется на основе данных и шаблонов.

##Компонентный подход в разработке
**Компонент** — это независимая сущность, которая описывает обособленный кусочек пользовательского интерфейса и содержит в себе весь необходимый код — HTML и JavaScript. Например, компонентом является кнопка или карточка товара.

####Цели создания компонентов:
* Переиспользование — компоненты легко переиспользовать на сайте.
* Структурирование — компоненты позволяют разделить большой код страницы на мелкие элементы, отвечающие за свою часть функционала. В результате появляется понятная структура файлов, в которой гораздо легче ориентироваться, чем в большой «простыне» кода.

###Признаки компонентов:
* Повторение элемента в макетах.
* В дальнейшем элемент потенциально может переиспользоваться.
* Элемент содержится в UI Kit.
* Логически обособленный элемент интерфейса.

## TypeScript

TypeScript расширяет возможности JavaScript. Добавляет новые операторы, упрощает реализацию концепций ООП и привносит в JS сильную статическую типизацию.

Сильная типизация решает проблему неявных преобразований между различными типами, а статическая позволяет проверить типы на этапе написания кода или компиляции.

**Список типов**
* any - разрешает всё, что угодно.
* unknown - гарантирует, что кто-то, использующий этот тип, уточнит его позже.
* never - значения, которые никогда не произойдут.
* void - функция, которая возвращает неопределённое или не имеет возвращаемого значения.

**Плюсы TS**
* Безопасное расширение JS
* Ошибки видны на этапе написания кода.
* Упрощается командная разработка.
* Расширенные подсказки от IDE, улучшенная навигация по коду.

**Минусы TS**
* Не всем проектам нужна типизация.
* Повышает порог входаю. Нужно начиться мыслить типами.
* Требуется компиляция. Замедление сборки.
* Не спасёт от ошибок во время выполнения кода.

TypeScript поддерживает кортежи. Кортеж — упорядоченный набор фиксированной длины. Кортежи похожи на массивы, даже синтаксис используется такой же. Но в отличии от последних, кортеж не может динамически расширяться, и типы значений, а также их количество известны заранее.


## Виртуальный DOM

**DOM (Document Object Model)** — объектная модель документа. DOM предоставляет интерфейсы, позволяющие программисту взаимодействовать с разметкой страницы: создавать и удалять элементы, изменять существующие, а также выполнять другие задачи.

**Виртуальный DOM** — это набор концепций (паттерн), которые позволяют обновлять интерфейс приложения более оптимальным способом.

Технически, виртуальный DOM — это обычный JavaScript-объект. Объект, который существует только в памяти.

Структура этого объекта похожа на DOM, но не содержит ничего лишнего. Из-за этого его нередко называют облегчённой копией DOM. Этот объект отражает текущее состояние экрана или попросту говоря соответствует текущему состоянию DOM.

**Теневой DOM** — это технология, которую предоставляет браузер и она позволяет определить области видимости переменных и CSS для веб-компонентов.

**Дженерики позволяют** определять параметры для типов. Дженерики лежат в основе обобщённого программирования, подхода, при котором один и тот же код одинаково работает с разными типами данных. Разработчик может определить параметры типа и передавать в них нужный тип в зависимости от контекста.

**Фреймворк** - готовый каркас для разработки приложения. Angular, Vue, Ember.

**Библиотека** - отдельный инструмент для решения какой-то задачи или несколько задач. JQuery, lodash.

Фреймворки дают основу проекта с готовым набором инструментов, начальную архитектуру, ограничения и т.д.

Библиотеки просто решают задачи. Они не предъявляют требования к фреймворкам или к архитектуре. Не закладывают дополнительные ограничения на проект. Просто делают свою работу, позволяя встраиваться в практически любое окружение или проект.

Перечисления (enum) - паттерн, который позволяет объединить несколько констант под одним именем.

**API - Data - View**

View генерирует события. События превращаются в запросы и отправляется к API. API возвращает данные, Данные поступают во View и View перерисовывается.

Хуки в React - это функции, которые позволяют использовать состояние и другие возможности React без написания классов. Хуки предоставляют более простой и элегантный способ управления состоянием компонентов и поведением жизненого цикла.

**Функциональный компонент** - это функция, которая получает данные и возвращает элемент интерфейса в качестве своего вызова.

**Классовый компонент** - представляет собой JavaScript-класс, унаследованный от класса Component, предоставляемого пакетом React.

**JSX** - это расширения языка JavaScript.

**Состояние** - набор атрибутов, определяющих поведение объекта. Изменение состояние объекта - это изменение его свойств.


# React


## Flux-архитектура
Глобальное состояние приложения — это часть состояния приложения, которое используется и изменяется в разных компонентах этого приложения.

Для управления глобальным состоянием существуют разные подходы. Одним из них является паттерн Flux, который подразумевает отделение состояния от дерева компонентов и односторонний поток данных. В рамках этого подхода изменять состояние может только специальная сущность — Диспетчер. Компоненты же, или Представление, только читают данные из Хранилища, а если нужно изменить состояние, то формируют Действие и передают его Диспетчеру.

## Redux

Redux — это библиотека на JavaScript, которая реализует паттерн Flux.

Redux нужен:
* требуется часто синхронизировать состояние между многими компонентами;
* постоянно приходится контролировать изменение состояния во времени — time travel debug;
* приходится перехватывать и вмешиваться в процесс изменения состояния, используя middleware.

Redux не зависит от фреймворков и библиотек, его можно использовать и без React.
### Структура
Важными сущностями Redux являются Действие — action, Хранилище — store и чистая функция reducer, взаимодействие с которой происходит с помощью метода store.dispatch().
* action - это объект Действие.
* dispatch - это метод, который предоставляет Хранилище, в которое передаётся Действие.
* reducer - это функция, которую разработчик сам пишет и передаёт её в Redux в момент создания Хранилища.
* store - это Хранилище

### Взаимодействие Redux с React
* Provider – компонент позволяет подключить к Хранилищу Redux дочерние компоненты. Хранилище передаётся в виде пропса store.
* useSelector – хук позволяет компоненту получить данные из Хранилища.
* useDispatch - хук позволяет получить доступ к методу store.dispatch(), чтобы диспатчить Действия из компонентов.
* connect() - функция для взаимодействия с Хранилищем из классовых компонентов React.

## Middleware
* Повторное использование. Middleware — это отдельная программа, а значит единожды написанный посредник может быть переиспользован в различных местах системы и даже в разных системах.
* Быстрое внедрение. Middleware написать проще, чем переработать систему целиком.
* Бесшовное внедрение разнородных систем. С помощью middleware в продукте можно использовать абсолютно разнородные системы.
* Экономическая эффективность. По причине первых трёх пунктов и ещё с десятка других.

### Middleware в Redux
Хотя в Redux middleware так же остаются верными перечисленные концепции, они решают несколько иную проблему. Посредник в Redux необходим для того, чтобы в момент между тем, как мы бросили экшен и его обработал редьюсер, можно было совершить какие-либо действия. Middleware — простой способ расширить функциональность Redux. Не нужно ждать, пока разработчики Redux добавят поддержку тех или иных функций, многие из них можно реализовать самостоятельно с помощью механизма middleware.

### Redux Thunk
Redux Thunk - middleware для Redux. С помощью этой функции можно расширить функциональность Redux, получая возможность отправлять (диспатчить) не только объекты, описывающие действия, но и функции. В них можно разместить код с побочными эффектами.
