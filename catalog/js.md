# JavaScript

**Интерфейс** - это набор всех свойств и элементов.

Первый принцип ООП заключается в том, что у каждого объекта есть чёткий фиксированный интерфейс.

**Инкапсуляция**

* объект должен быть чёрным ящиком.
* разработчик взаимодействует с объектом через публичный интерфейс.
* нельзя вторгаться во внутренние механизмы класса снаружи (при переопределении - можно).

**Наследование** - это один из способов использовать методы и свойства одних объектов (родителей) в других объектах (потомках).

**Датабиндинг** (связывание данных) - это связь между пользовательским интерфейсом пользователя и бизнес-логикой.

Датабиндинг прекрасен тем, что при правильной настройке связей мы изменить данные, а разметка изменится самостоятельно следом за ними.

**Бизнес-логика** - правила и ограничения реального мира, которые описываются с помощью компьютерной программы.

**Иммутабельность** - неизменяемость, когда какие-то данные нельзя изменить, можно только записать на их место другие.

**Иммутабельность** - это механизм контроля над тем, какие части кода могут произвести изменения значения.

## Веб-приложения

В основе любого веб-приложения три компонента: HTML (структура интерфейса), CSS (оформление) и JavaScript (поведение).

* Multi Page Application (MPA) — это приложения, которые состоят из нескольких HTML-страниц. Главная особенность MPA — полная перезагрузка страницы при переходе между разными страницами приложения. Каждая страница предоставляет определённую функциональность веб-приложения.
* Single Page Application (SPA) — это веб-приложение, которое работает в рамках одной HTML-страницы. Кклиент загружает её со всеми ресурсами один раз при первом посещении приложения. Все дальнейшие действия пользователя происходят без перезагрузки страницы.
* Progressive Web Application (PWA) - веб-приложение сочетающее преимущества обычных сайтов и нативных приложений: быстрая загрузка, установка в ОС, работа в офлайне, пуш-уведомления, доступ к системным API.
* Server-Side Rendering (SSR) — в этом веб-приложении за подготовку HTML-кода отвечает сервер. Страница генерируется каждый раз при очередном обращении клиента. Клиенту отправляется готовый HTML, стили и при необходимости JavaScript. С точки зрения клиента, это мало чем отличается от MPA. SSR приложения хорошо подходят для SEO. Но может возрастать нагрузка на сервер, так на каждый запрос клиента приходится заново генерировать страницы.
* Static Site Generator (SSG) - в этом веб-приложении статический HTML формируется на основе данных и шаблонов.

## Компонентный подход в разработке

**Компонент** — это независимая сущность, которая описывает обособленный кусочек пользовательского интерфейса и содержит в себе весь необходимый код — HTML и JavaScript. Например, компонентом является кнопка или карточка товара.

#### Цели создания компонентов:

* Переиспользование — компоненты легко переиспользовать на сайте.
* Структурирование — компоненты позволяют разделить большой код страницы на мелкие элементы, отвечающие за свою часть функционала. В результате появляется понятная структура файлов, в которой гораздо легче ориентироваться, чем в большой «простыне» кода.

### Признаки компонентов:

* Повторение элемента в макетах.
* В дальнейшем элемент потенциально может переиспользоваться.
* Элемент содержится в UI Kit.
* Логически обособленный элемент интерфейса.

## TypeScript

TypeScript расширяет возможности JavaScript. Добавляет новые операторы, упрощает реализацию концепций ООП и привносит в JS сильную статическую типизацию.

Сильная типизация решает проблему неявных преобразований между различными типами, а статическая позволяет проверить типы на этапе написания кода или компиляции.

**Список типов**

* any - разрешает всё, что угодно.
* unknown - гарантирует, что кто-то, использующий этот тип, уточнит его позже.
* never - значения, которые никогда не произойдут.
* void - функция, которая возвращает неопределённое или не имеет возвращаемого значения.

**Плюсы TS**

* Безопасное расширение JS
* Ошибки видны на этапе написания кода.
* Упрощается командная разработка.
* Расширенные подсказки от IDE, улучшенная навигация по коду.

**Минусы TS**

* Не всем проектам нужна типизация.
* Повышает порог входа. Нужно начинать мыслить типами.
* Требуется компиляция. Замедление сборки.
* Не спасёт от ошибок во время выполнения кода.

TypeScript поддерживает кортежи. Кортеж — упорядоченный набор фиксированной длины. Кортежи похожи на массивы, даже синтаксис используется такой же. Но в отличие от последних, кортеж не может динамически расширяться, и типы значений, а также их количество известны заранее.

## Типизация

**Динамическая типизация.** В языках с динамической типизацией, типы определяются и проверяются во время выполнения программы, в рантайме. За счёт этого, например, становится возможным беспрепятственно сохранять в одну переменную значения разных типов.
Основной минус: вероятность совершить ошибку увеличивается.
Плюсы тоже есть. Один из них — более низкий порог входа. Разработчику не нужно думать о многих вещах заранее, поэтому языки с динамической типизацией, как правило, более просты в изучении. Хорошо подходят для первого языка программирования.

И это не единственный плюс. Скорость разработки небольших приложений возрастает. Это опять же связано с отсутствием необходимости думать о типах на этапе разработки. В языках с динамической типизацией проще описывать массивы, коллекции, которые содержат значения разных типов. JavaScript (или схожий язык) во всём разберётся сам.

**Статическая типизация.** Всю необходимую информацию о типах они узнают до выполнения программы. Это возможно за счёт этапа компиляции. Перед выполнением программы, исходный код должен быть скомпилирован в более низкоуровневый код. Во время этого процесса и происходит проверка типов. Поскольку информация о типах известна на этапе написания кода, легко обнаружить многие из потенциальных проблем.

Главный плюс статической компиляции — повышение надёжности. Информация о потенциальных проблемах появляется при написании кода, а не во время его выполнения.

Побочный плюс: разработка «ускоряется». С одной стороны, разработчику приходится думать о типах, вместо фокусировки над задачей. С другой, за счёт проверок компилятором, появляется возможность встроить в IDE дополнительные функции. Они и помогут ускорить процесс разработки. Автодополнение кода, расширенная навигация по коду, функции рефакторинга, подсказки и многое другое.

Минусы у статической типизации тоже есть. Про самый весомый мы говорили, когда разбирались с динамической типизацией — порог входа выше. Выразить решение некоторых задач становится сложней. Различные алгоритмы, работающие с разными типами данных — яркий тому пример.

**Сильная и слабая**

**Явная и неявная**

## Виртуальный DOM

**DOM (Document Object Model)** — объектная модель документа. DOM предоставляет интерфейсы, позволяющие программисту взаимодействовать с разметкой страницы: создавать и удалять элементы, изменять существующие, а также выполнять другие задачи.

**Виртуальный DOM** — это набор концепций (паттерн), которые позволяют обновлять интерфейс приложения более оптимальным способом.

Технически, виртуальный DOM — это обычный JavaScript-объект. Объект, который существует только в памяти.

Структура этого объекта похожа на DOM, но не содержит ничего лишнего. Из-за этого его нередко называют облегчённой копией DOM. Этот объект отражает текущее состояние экрана или попросту говоря соответствует текущему состоянию DOM.

**Теневой DOM** — это технология, которую предоставляет браузер и она позволяет определить области видимости переменных и CSS для веб-компонентов.

**Дженерики позволяют** определять параметры для типов. Дженерики лежат в основе обобщённого программирования, подхода, при котором один и тот же код одинаково работает с разными типами данных. Разработчик может определить параметры типа и передавать в них нужный тип в зависимости от контекста.

**Фреймворк** - готовый каркас для разработки приложения. Angular, Vue, Ember.

**Библиотека** - отдельный инструмент для решения какой-то задачи или несколько задач. JQuery, lodash.

Фреймворки дают основу проекта с готовым набором инструментов, начальную архитектуру, ограничения и т.д.

Библиотеки просто решают задачи. Они не предъявляют требования к фреймворкам или к архитектуре. Не закладывают дополнительные ограничения на проект. Просто делают свою работу, позволяя встраиваться в практически любое окружение или проект.

Перечисления (enum) - паттерн, который позволяет объединить несколько констант под одним именем.

**API - Data - View**

View генерирует события. События превращаются в запросы и отправляется к API. API возвращает данные, Данные поступают во View и View перерисовывается.

Хуки в React - это функции, которые позволяют использовать состояние и другие возможности React без написания классов. Хуки предоставляют более простой и элегантный способ управления состоянием компонентов и поведением жизненого цикла.

**Функциональный компонент** - это функция, которая получает данные и возвращает элемент интерфейса в качестве своего вызова.

**Классовый компонент** - представляет собой JavaScript-класс, унаследованный от класса Component, предоставляемого пакетом React.

**JSX** (JavaScript XML) - это расширение языка JavaScript, которое помогает описывать HTML-подобные элементы с помощью кода на React. С помощью синтаксиса на React создают компоненты страницы и гибко управляют ими.

**XML** (Extensible Markup Language - Расширяемый Язык Разметки) - это язык разметки подобный HTML. Является рекомендацией сообщества W3C в качестве языка разметки общего назначения. В отличие от остальных языков разметки, XML сам по себе не определён (это означает, что вы должны сами определять используемые теги).

**Состояние** - набор атрибутов, определяющих поведение объекта. Изменение состояние объекта - это изменение его свойств.

## Модули

### Области видимости переменных и функций

Механизм областей видимости в JavaScript ограничивает видимость переменных и функций в разных частях программы, иначе бы разработчикам пришлось придумывать уникальные имена для всех переменных и функций в программе.

**Глобальная область видимости** - Самая верхняя в иерархии областей видимости. Родительская для всех. Переменные, объявленные в глобальной области видимости, доступны везде на странице.
Благодаря глобальной области видимости можно объявить переменную в одном файле, задать ей значение в другом файле, а воспользоваться — вообще в третьем месте. До появления модулей в JavaScript у глобальной области видимости было одно преимущество: с её помощью можно обмениваться данными между подключёнными к странице JS-файлами. Сейчас, когда в JavaScript есть модули, остались одни недостатки. И основной недостаток — это возможность случайно изменить значение глобальной переменной в одном из файлов, так сказать затереть исходное значение.

**Блочная область видимости** - Самая универсальная из областей, ограничителем выступает блок кода {}. Переменные, объявленные в блочной области видимости, доступны в ней самой и во вложенных в неё других блочных областях.

**Модульная область видимости** - это область видимости, создаваемая модулем. В область видимости модуля попадают переменные и функции, объявленные «прямо в JS-модуле».

### ECMAScript-модули

**Модуль** — это функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом.

**Законченный фрагмент кода** — это фрагмент, который выполняет конкретно поставленную задачу и ничего лишнего.

**Преимущества модульного подхода**

* Каждая команда фокусируется на своей задаче.
* Некоторые команды могут делать свою работу параллельно и независимо друг от друга.
* Команду или результат её работы можно легко заменить (в сравнении с немодульным подходом). Пример выше — в самолёт без проблем можно установить салон другой комплектации или от другого производителя, не изменяя конструкцию самолёта.

**Задачи модуля**

* **Пространство имён.** Модуль изолирует пространство имён, чтобы переменные из одного модуля не попадали в другой модуль, как это бывает с глобальными переменными. Всё, что создаётся в модуле, остаётся в модуле.
* **Зависимости.** Модуль должен описывать и давать понимание, какие у него есть зависимости. Например, модуль может зависеть от других модулей.
* **Интерфейс.** Модуль должен описывать интерфейс — методы и свойства — которые он может предоставить другим модулям.

**Импорт — не объявление**

Важно помнить, что импорт переменной не то же самое, что её объявление. При импорте переменная не создаётся, а честно импортируется, самая настоящая переменная из другого модуля. Такое поведение справедливо для всех видов импорта, которые мы разберём дальше (экспортировать как-то иначе тоже нельзя), поэтому будьте внимательны при работе с импортированными переменными. Ведь сложные типы данных, вроде объектов или массивов, при импорте передаются по ссылке, и их можно нечаянно испортить:

**Нюансы**

* **Код модуля выполняется целиком.** Если модуль импортирован, его код будет выполнен целиком независимо от способа импорта.
* **Только первый уровень.** import и export не могут быть вложены в функции или другие блоки кода:
* **Никакого поднятия** (hoisting). Импортированные переменные не поднимаются, поэтому import всегда должен быть в начале файла:
* **Путь — константа.** Путь в конструкции import является константой и не может быть сборным.

## Промисы

**Промис** — это глобальный объект Promise (с англ. «обещание»). Он позволяет отследить выполнение асинхронной операции и сохранить её результат. Сами асинхронные операции выполняются как и прежде: не сразу, а когда-нибудь. Промисы - это просто объект, позволяющий более эффективно работать с асинхронным кодом. Промисы - это способ борьбы с «адом колбеков». Промисы позволяют организовать асинхронный код по-другому: сделать его более плоским и последовательным, похожим на синхронный код.

**Ад колбэков** - это код на JavaScript, в котором используется много-много вложенных функций обратного вызова. Так много, что в таком коде трудно интуитивно разобраться.

**Особенности**

* Функция-исполнитель выполняется сразу.
* Промис может находиться в трёх состояниях.
* Нет возможности откатиться к предыдущему состоянию.

**Состояния промиса**

* pending — выполняется
* settled — завершён:
  * fulfilled — завершён успешно
  * rejected — завершён с ошибкой

**Методы**

* **then()** - этот метод передаёт результат.
* **catch()** - этот метод для обработки перехода промиса в состояние завершён с ошибкой.
* **finally()** - этот метод для выполнения функцию вне зависимости от того, завершился промис успешно или с ошибкой.
* **all()** - этот метод может пригодиться в ситуациях, когда требуется дождаться завершения нескольких промисов. Метод принимает в качестве единственного аргумента массив из промисов и возвращает новый промис, который будет завершён успешно, как только завершатся успешно все переданные в all() промисы. Если хоть один переданный в all() промис завершится с ошибкой, тогда и промис all() будет завершён с ошибкой.
* **race()** - этот метод не будет ждать завершения всех промисов, а дождётся завершения одного, который «придёт первым к финишу»
* **resolve()** - метод для проверки кода, который возвращает промис в состоянии завершён успешно.
* **reject()** - метод для проверки кода, который возвращает промис в состоянии завершён с ошибкой.

Методы then(), catch() и finally() всегда возвращают новый промис. За счёт этого появляется возможность строить цепочки вызовов промисов.

## Async/Await

В основе работы операторов async и await лежат промисы, просто эти операторы позволяют использовать промисы в другом синтаксисе. Их задача ещё больше упростить написание асинхронного кода и сделать его похожим (визуально!) на синхронный.

* **async** - этот оператор позволяет определить асинхронную функцию. Результатом выполнения такой функции всегда будет новый промис. async применяется при объявлении функций как декларативно, так и для функций-выражений.
* **await** - этот оператор позволяет дождаться выполнения промиса, за счёт чего достигается сходство с синхронным кодом. Иными словами оператор await вместе с оператором async образуют тандем, который как раз позволяет сделать асинхронный код похожим на синхронный.

При использовании async и await обрабатывать ошибки можно с помощью конструкции try...catch.

## JSON

JSON (JavaScript Object Notation) — открытый текстовый формат для обмена данными. Формат разработан Дугласом Крокфордом. Отличительная особенность формата — его легко интерпретировать не только машинам, но и людям.

Содержимое JSON — это коллекция из пар ключ/значение. Ключи определяются слева, а значение отделяется символом двоеточия (:).

**Структуры данных**

* коллекция из пар ключ/значение
* упорядоченный список значений

**Типы данных**

* строковые
* числовые
* булевы
* null

## Fetch API

**Fetch API** — современный, гибкий и универсальный способ для отправки запросов к серверу. Способ реализуется с помощью функции fetch(). В простых случаях можно обойтись буквально одной строчкой кода, а за счёт поддержки промисов обработка ответов также упрощается и превращается в последовательную цепочку.
Функция принимает два параметра: адрес ресурса, на который требуется отправить запрос, и объект с настройками, где переопределяем HTTP-метод (опционален). Результатом выполнения fetch() станет промис.

**Объект ответа (Response)** мы получаем при завершении промиса. В этом объекте хранится вся информация об ответе сервера: заголовки, статусы, результат выполнения запроса и другая служебная информация.

Определить успешность выполнения запроса поможет свойство объекта ответа ok. Оно содержит булево значение. Если запрос выполнен успешно, ok будет true. В противном случае false.

Звучит не сложно, но возникает другой вопрос: «А что подразумевается под успехом выполнения?» Успех определяется на основании кода ответа сервера на запрос. Если код ответа в диапазоне чисел 200-299, значит он выполнился успешно. Ответы с кодами, которые не попадают в диапазон, означают выполнение запроса с ошибкой.

## Методы

### Взаимодействие с DOM

* **getElementById** — поиск элемента по идентификатору;
* **getElementsByClassName** — поиск элементов по названию класса;
* **getElementsByTagName** — поиск элементов по названию тега;
* **querySelector** — поиск первого элемента, подходящего под CSS-селектор;
* **querySelectorAll** — поиск всех элементов подходящих под CSS-селектор.

## Типы данных

## Расширенные типы данных (TypedArray)

## Объекты и примитивы

## Виды функций (простые и стрелочные), IIFE

## .bind, .apply, .call

## Понимание замыканий

## Понимание асинхронности

## Синтаксис классов

## Работа с прототипами

## ES Modules

## Умение перенести CommonJS в ESM

## TypeScript

## Умение описывать типы

## Умение описывать сложные типы

## Умение работать с дженериками

## Умение мыслить типами

## Умение обновлять версию TS в проекте

## SPA: React, Vue, Angular

## SSR

## SSG

## Производительность и профилирование

## Умение работать со стейт менеджерами

## Data Access Layer (DAL)

## npm (pnpm, yarn)

## Знает чем отличается

## Как работает package-lock.json

## Умение разбирать конфликты зависимостей

## Умение выделить из проекта компонент для публикации

## уметь работать со сборкой

## Базовые знания как писать свой конфиг

## FrontOps

## Анализ и оптимизация бандлов

## Умение пользоваться Intl

## Работа с датами

## Понимание как развивается JavaScript

## Знание о движках и оптимизации под них
