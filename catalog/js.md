# JavaScript

**Интерфейс** - это набор всех свойств и элементов.

Первый принцип ООП заключается в том, что у каждого объекта есть чёткий фиксированный интерфейс.

**Инкапсуляция**

* объект должен быть чёрным ящиком.
* разработчик взаимодействует с объектом через публичный интерфейс.
* нельзя вторгаться во внутренние механизмы класса снаружи (при переопределении - можно).

**Наследование** - это один из способов использовать методы и свойства одних объектов (родителей) в других объектах (потомках).

**Датабиндинг** (связывание данных) - это связь между пользовательским интерфейсом пользователя и бизнес-логикой.

Датабиндинг прекрасен тем, что при правильной настройке связей мы изменить данные, а разметка изменится самостоятельно следом за ними.

**Бизнес-логика** - правила и ограничения реального мира, которые описываются с помощью компьютерной программы.

**Иммутабельность** - неизменяемость, когда какие-то данные нельзя изменить, можно только записать на их место другие.

**Иммутабельность** - это механизм контроля над тем, какие части кода могут произвести изменения значения.

## Веб-приложения

В основе любого веб-приложения три компонента: HTML (структура интерфейса), CSS (оформление) и JavaScript (поведение).

* Multi Page Application (MPA) — это приложения, которые состоят из нескольких HTML-страниц. Главная особенность MPA — полная перезагрузка страницы при переходе между разными страницами приложения. Каждая страница предоставляет определённую функциональность веб-приложения.
* Single Page Application (SPA) — это веб-приложение, которое работает в рамках одной HTML-страницы. Кклиент загружает её со всеми ресурсами один раз при первом посещении приложения. Все дальнейшие действия пользователя происходят без перезагрузки страницы.
* Progressive Web Application (PWA) - веб-приложение сочетающее преимущества обычных сайтов и нативных приложений: быстрая загрузка, установка в ОС, работа в офлайне, пуш-уведомления, доступ к системным API.
* Server-Side Rendering (SSR) — в этом веб-приложении за подготовку HTML-кода отвечает сервер. Страница генерируется каждый раз при очередном обращении клиента. Клиенту отправляется готовый HTML, стили и при необходимости JavaScript. С точки зрения клиента, это мало чем отличается от MPA. SSR приложения хорошо подходят для SEO. Но может возрастать нагрузка на сервер, так на каждый запрос клиента приходится заново генерировать страницы.
* Static Site Generator (SSG) - в этом веб-приложении статический HTML формируется на основе данных и шаблонов.

##Компонентный подход в разработке

**Компонент** — это независимая сущность, которая описывает обособленный кусочек пользовательского интерфейса и содержит в себе весь необходимый код — HTML и JavaScript. Например, компонентом является кнопка или карточка товара.

####Цели создания компонентов:

* Переиспользование — компоненты легко переиспользовать на сайте.
* Структурирование — компоненты позволяют разделить большой код страницы на мелкие элементы, отвечающие за свою часть функционала. В результате появляется понятная структура файлов, в которой гораздо легче ориентироваться, чем в большой «простыне» кода.

###Признаки компонентов:

* Повторение элемента в макетах.
* В дальнейшем элемент потенциально может переиспользоваться.
* Элемент содержится в UI Kit.
* Логически обособленный элемент интерфейса.

## TypeScript

TypeScript расширяет возможности JavaScript. Добавляет новые операторы, упрощает реализацию концепций ООП и привносит в JS сильную статическую типизацию.

Сильная типизация решает проблему неявных преобразований между различными типами, а статическая позволяет проверить типы на этапе написания кода или компиляции.

**Список типов**

* any - разрешает всё, что угодно.
* unknown - гарантирует, что кто-то, использующий этот тип, уточнит его позже.
* never - значения, которые никогда не произойдут.
* void - функция, которая возвращает неопределённое или не имеет возвращаемого значения.

**Плюсы TS**

* Безопасное расширение JS
* Ошибки видны на этапе написания кода.
* Упрощается командная разработка.
* Расширенные подсказки от IDE, улучшенная навигация по коду.

**Минусы TS**

* Не всем проектам нужна типизация.
* Повышает порог входаю. Нужно начиться мыслить типами.
* Требуется компиляция. Замедление сборки.
* Не спасёт от ошибок во время выполнения кода.

TypeScript поддерживает кортежи. Кортеж — упорядоченный набор фиксированной длины. Кортежи похожи на массивы, даже синтаксис используется такой же. Но в отличии от последних, кортеж не может динамически расширяться, и типы значений, а также их количество известны заранее.

## Типизация

**Динамическая типизация.** В языках с динамической типизацией, типы определяются и проверяются во время выполнения программы, в рантайме. За счёт этого, например, становится возможным беспрепятственно сохранять в одну переменную значения разных типов.
Основной минус: вероятность совершить ошибку увеличивается.
Плюсы тоже есть. Один из них — более низкий порог входа. Разработчику не нужно думать о многих вещах заранее, поэтому языки с динамической типизацией, как правило, более просты в изучении. Хорошо подходят для первого языка программирования.

И это не единственный плюс. Скорость разработки небольших приложений возрастает. Это опять же связано с отсутствием необходимости думать о типах на этапе разработки. В языках с динамической типизацией проще описывать массивы, коллекции, которые содержат значения разных типов. JavaScript (или схожий язык) во всём разберётся сам.

**Статическая типизация.** Всю необходимую информацию о типах они узнают до выполнения программы. Это возможно за счёт этапа компиляции. Перед выполнением программы, исходный код должен быть скомпилирован в более низкоуровневый код. Во время этого процесса и происходит проверка типов. Поскольку информация о типах известна на этапе написания кода, легко обнаружить многие из потенциальных проблем.

Главный плюс статической компиляции — повышение надёжности. Информация о потенциальных проблемах появляется при написании кода, а не во время его выполнения.

Побочный плюс: разработка «ускоряется». С одной стороны, разработчику приходится думать о типах, вместо фокусировки над задачей. С другой, за счёт проверок компилятором, появляется возможность встроить в IDE дополнительные функции. Они и помогут ускорить процесс разработки. Автодополнение кода, расширенная навигация по коду, функции рефакторинга, подсказки и многое другое.

Минусы у статической типизации тоже есть. Про самый весомый мы говорили, когда разбирались с динамической типизацией — порог входа выше. Выразить решение некоторых задач становится сложней. Различные алгоритмы, работающие с разными типами данных — яркий тому пример.

**Сильная и слабая**

**Явная и неявная**

## Виртуальный DOM

**DOM (Document Object Model)** — объектная модель документа. DOM предоставляет интерфейсы, позволяющие программисту взаимодействовать с разметкой страницы: создавать и удалять элементы, изменять существующие, а также выполнять другие задачи.

**Виртуальный DOM** — это набор концепций (паттерн), которые позволяют обновлять интерфейс приложения более оптимальным способом.

Технически, виртуальный DOM — это обычный JavaScript-объект. Объект, который существует только в памяти.

Структура этого объекта похожа на DOM, но не содержит ничего лишнего. Из-за этого его нередко называют облегчённой копией DOM. Этот объект отражает текущее состояние экрана или попросту говоря соответствует текущему состоянию DOM.

**Теневой DOM** — это технология, которую предоставляет браузер и она позволяет определить области видимости переменных и CSS для веб-компонентов.

**Дженерики позволяют** определять параметры для типов. Дженерики лежат в основе обобщённого программирования, подхода, при котором один и тот же код одинаково работает с разными типами данных. Разработчик может определить параметры типа и передавать в них нужный тип в зависимости от контекста.

**Фреймворк** - готовый каркас для разработки приложения. Angular, Vue, Ember.

**Библиотека** - отдельный инструмент для решения какой-то задачи или несколько задач. JQuery, lodash.

Фреймворки дают основу проекта с готовым набором инструментов, начальную архитектуру, ограничения и т.д.

Библиотеки просто решают задачи. Они не предъявляют требования к фреймворкам или к архитектуре. Не закладывают дополнительные ограничения на проект. Просто делают свою работу, позволяя встраиваться в практически любое окружение или проект.

Перечисления (enum) - паттерн, который позволяет объединить несколько констант под одним именем.

**API - Data - View**

View генерирует события. События превращаются в запросы и отправляется к API. API возвращает данные, Данные поступают во View и View перерисовывается.

Хуки в React - это функции, которые позволяют использовать состояние и другие возможности React без написания классов. Хуки предоставляют более простой и элегантный способ управления состоянием компонентов и поведением жизненого цикла.

**Функциональный компонент** - это функция, которая получает данные и возвращает элемент интерфейса в качестве своего вызова.

**Классовый компонент** - представляет собой JavaScript-класс, унаследованный от класса Component, предоставляемого пакетом React.

**JSX** - это расширения языка JavaScript.

**Состояние** - набор атрибутов, определяющих поведение объекта. Изменение состояние объекта - это изменение его свойств.

# React

## Flux-архитектура

Глобальное состояние приложения — это часть состояния приложения, которое используется и изменяется в разных компонентах этого приложения.

Для управления глобальным состоянием существуют разные подходы. Одним из них является паттерн Flux, который подразумевает отделение состояния от дерева компонентов и односторонний поток данных. В рамках этого подхода изменять состояние может только специальная сущность — Диспетчер. Компоненты же, или Представление, только читают данные из Хранилища, а если нужно изменить состояние, то формируют Действие и передают его Диспетчеру.

## Redux

Redux — это библиотека на JavaScript, которая реализует паттерн Flux.

Redux нужен:

* требуется часто синхронизировать состояние между многими компонентами;
* постоянно приходится контролировать изменение состояния во времени — time travel debug;
* приходится перехватывать и вмешиваться в процесс изменения состояния, используя middleware.

Redux не зависит от фреймворков и библиотек, его можно использовать и без React.

### Структура

Важными сущностями Redux являются Действие — action, Хранилище — store и чистая функция reducer, взаимодействие с которой происходит с помощью метода store.dispatch().

* action - это объект Действие.
* dispatch - это метод, который предоставляет Хранилище, в которое передаётся Действие.
* reducer - это функция, которую разработчик сам пишет и передаёт её в Redux в момент создания Хранилища.
* store - это Хранилище

### Взаимодействие Redux с React

* Provider – компонент позволяет подключить к Хранилищу Redux дочерние компоненты. Хранилище передаётся в виде пропса store.
* useSelector – хук позволяет компоненту получить данные из Хранилища.
* useDispatch - хук позволяет получить доступ к методу store.dispatch(), чтобы диспатчить Действия из компонентов.
* connect() - функция для взаимодействия с Хранилищем из классовых компонентов React.

## Middleware

* Повторное использование. Middleware — это отдельная программа, а значит единожды написанный посредник может быть переиспользован в различных местах системы и даже в разных системах.
* Быстрое внедрение. Middleware написать проще, чем переработать систему целиком.
* Бесшовное внедрение разнородных систем. С помощью middleware в продукте можно использовать абсолютно разнородные системы.
* Экономическая эффективность. По причине первых трёх пунктов и ещё с десятка других.

### Middleware в Redux

Хотя в Redux middleware так же остаются верными перечисленные концепции, они решают несколько иную проблему. Посредник в Redux необходим для того, чтобы в момент между тем, как мы бросили экшен и его обработал редьюсер, можно было совершить какие-либо действия. Middleware — простой способ расширить функциональность Redux. Не нужно ждать, пока разработчики Redux добавят поддержку тех или иных функций, многие из них можно реализовать самостоятельно с помощью механизма middleware.

### Redux Thunk

Redux Thunk - middleware для Redux. С помощью этой функции можно расширить функциональность Redux, получая возможность отправлять (диспатчить) не только объекты, описывающие действия, но и функции. В них можно разместить код с побочными эффектами.

### Оптимизация

**Что оптимизировать?**

* **Производительность.** Мы можем оптимизировать производительность, чтобы приложение стало более быстрым и отзывчивым для конечного пользователя.
* **Код.** Вести и придерживаться стиля кодирования, чтобы вашим коллегам было проще разобраться в коде, написанном вами, и наоборот. Потому что если код будет простым и понятным, его будет проще (оптимальнее) поддерживать и дорабатывать. Плюс, ваш технический долг будет увеличиваться существенно медленнее.
* **Процессы.** Имеются ввиду процессы в команде. Это и постановка задач, и ревью кода и всё остальное. Например, чтобы ускорить проверку домашних заданий, вы можете договориться с наставником о конкретном и регулярном времени проверки. Тогда вы будете знать в какое именно время стоит отправлять свою работу, а наставник сможет её регулярно проверять.

**Сложности оптимизации**

* **Производительность кода обратно пропорциональна его читабельности.** Об этом нужно помнить всякий раз, когда вы хотите использовать !!value вместо Boolean(value), вложенный тернарный оператор вместо if, оператор ~ вместо сравнения на меньше нуля и т. д.
* **Оптимизация требует анализа.** «Нельзя просто так взять и» оптимизировать приложение или его код. Прежде необходимо провести анализ и выявить неоптимальные участки. После продумать стратегию оптимизации. И только потом уже предпринимать какие-либо действия.
* **Преждевременная оптимизация — зло.** Оптимизировать что-либо без запроса на эту самую оптимизацию, например, отзывов пользователей, это напрасная трата времени в данный момент.

Когда нужно оптимизировать производительность?

* Когда о проблеме производительности будут писать пользователи
* Проверка с помощью специальных инструментов

**Анализаторы**

* Dynatrace Application Monitoring. Инструмент для мониторинга приложения целиком. От бэкенда до фронтенда.
* PageSpeed Insights. Анализатор конкретной страницы вашего приложения.

**Профайлеры**

* Chrome DevTools или Firefox DevTools. Вкладка Perfomance (Производительность).
* React Profiler — часть React DevTools. Профайлер, похожий на встроенный браузерный, только заточенный под React:
  * React Profiler для Chrome.
  * React Profiler для Firefox.

**Полезные инструменты консоли**

* Обложить ту часть приложения, производительность которой необходимо замерить, вызовами console.time.
* Или, ещё лучше, обложив window.perfomance (Perfomance API).

**Способы оптимизации**

* **Упрощайте код и выбрасывайте из него всё лишнее.** Это не значит, что в угоду оптимизации нужно избавляться от части функциональности. Например, большой и сложный компонент нужно не выбрасывать, а разделить на несколько маленьких и простых.
* **Применяйте известные паттерны.** Любые паттерны возникают в момент решения часто встречающихся проблем и проверяются временем и делом. Поэтому старайтесь использовать чужой опыт, а не наступать на свои грабли.
* **Изучайте новые паттерны.** Это поможет не попасть в анекдотичную ситуацию, известную как «золотой молоток».

##Сборки
**Причины для использования сборки.**

* **Неизвестный для браузера синтаксис.** Для удобства разработки современные инструменты часто расширяют синтаксис языков. Например, JSX и TypeScript дополняют JavaScript конструкциями, которые неизвестны браузеру. Но если браузер будет преобразовывать JSX и TypeScript в JavaScript в режиме реального времени на устройстве пользователя, это снизит производительность сайта. Гораздо эффективнее на этапе сборки преобразовать весь код в чистый JavaScript без инородного кода и уже его отправить пользователю в браузер.
* **Разбиение на файлы-модули.** В крупных проектах исходный код разбивается на несколько файлов. Для оптимальной работы сайта файлы нужно делить, исходя из минимизации потребления ресурсов, а не удобства использования. Эта дилемма также решается применением сборки. Можно писать код, разбивая на модули, как вам удобно. А далее система сборки перегруппирует код и разделит на файлы, чтобы страница загружалась и работала оптимально.
* **Минификация.** И вновь на помощь приходит сборка. Мы можем писать понятный для разработчиков код, не беспокоясь о его объёме, потому что на этапе сборки он будет минифицирован. Этап сборки выполняется на компьютере разработчика. Программа преобразует код сайта, написанный программистом, в более эффективный для работы в браузере. И уже этот новый код попадает на сайт.

## Node.js

Во фронтенде для сборки обычно применяется среда Node.js.

**Node.js** — это кросс-платформенная среда выполнения JavaScript с открытым исходным кодом.

**npm** (Node Package Manager) — менеджер пакетов для JavaScript, входящий в состав Node.js.

Npm позволяет разработчикам по всему миру загружать свои решения популярных задач в виде отдельных модулей — JavaScript-пакетов. Другие разработчики могут получить эти пакеты через npm и использовать в своём проекте. Npm-пакеты особенно актуальны при сборке проекта. Большинство проблем при решении этой задачи — типовые, хоть и сложные. Они повторяются из проекта в проект, поэтому их уже неоднократно решало множество разработчиков. И вместо того, чтобы писать собственный код, проще взять готовый модуль.

**Сборщики модулей**

* Webpack
* Esvuild
* Pollup
* Vite
* Parcel

**Vite**
Vite — это набор инструментов для разработки современных фронтенд-приложений. Он предоставляет сервер для разработки, поддержку TypeScript, JSX, CSS и многое другое из коробки. Отличается простым конфигурированием и возможностью расширения за счёт внешних плагинов.

**Полифил** — это код, который реализует новую функциональность с помощью уже имеющихся в языке конструкций. Например, если мы имеем дело с очень старым браузером, который не поддерживает метод массива map, то можно написать собственный, делающий то же самое, и «прикрутить» его к глобальному объекту Array. Таким образом с помощью полифилов можно имитировать многие новые функции языка. Но не все. Если новый стандарт не просто добавляет какую-то функциональность, а вводит новый синтаксис, простых полифилов не хватит. Ведь, встретив незнакомую конструкцию, браузер выбросит ошибку, и код сломается. Так что в этом случае нужно средство помощнее — транспиляция.

Термин «транспиляция» составлен из двух частей: трансформации и компиляции. И это в общих чертах описывает то, что при ней происходит. Программы-транспиляторы берут один «диалект» языка, например ECMAScript 2022, и преобразуют его в другой, например ECMAScript 5.

**Babel** — это транспилятор, способный преобразовывать различные расширения синтаксиса JavaScript в обычный JavaScript, а также трансформировать конструкции из современного стандарта в более старые стандарты.

##Модули

###Области видимости переменных и функций
Механизм областей видимости в JavaScript ограничивает видимость переменных и функций в разных частях программы, иначе бы разработчикам пришлось придумывать уникальные имена для всех переменных и функций в программе.

**Глобальная область видимости** - Самая верхняя в иерархии областей видимости. Родительская для всех. Переменные, объявленные в глобальной области видимости, доступны везде на странице.
Благодаря глобальной области видимости можно объявить переменную в одном файле, задать ей значение в другом файле, а воспользоваться — вообще в третьем месте. До появления модулей в JavaScript у глобальной области видимости было одно преимущество: с её помощью можно обмениваться данными между подключёнными к странице JS-файлами. Сейчас, когда в JavaScript есть модули, остались одни недостатки. И основной недостаток — это возможность случайно изменить значение глобальной переменной в одном из файлов, так сказать затереть исходное значение.

**Блочная область видимости** - Самая универсальная из областей, ограничителем выступает блок кода {}. Переменные, объявленные в блочной области видимости, доступны в ней самой и во вложенных в неё других блочных областях.

**Модульная область видимости** - это область видимости, создаваемая модулем. В область видимости модуля попадают переменные и функции, объявленные «прямо в JS-модуле».

###ECMAScript-модули
**Модуль** — это функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом.

**Законченный фрагмент кода** — это фрагмент, который выполняет конкретно поставленную задачу и ничего лишнего.

**Преимущества модульного подхода**

* Каждая команда фокусируется на своей задаче.
* Некоторые команды могут делать свою работу параллельно и независимо друг от друга.
* Команду или результат её работы можно легко заменить (в сравнении с немодульным подходом). Пример выше — в самолёт без проблем можно установить салон другой комплектации или от другого производителя, не изменяя конструкцию самолёта.

**Задачи модуля**

* **Пространство имён.** Модуль изолирует пространство имён, чтобы переменные из одного модуля не попадали в другой модуль, как это бывает с глобальными переменными. Всё, что создаётся в модуле, остаётся в модуле.
* **Зависимости.** Модуль должен описывать и давать понимание, какие у него есть зависимости. Например, модуль может зависеть от других модулей.
* **Интерфейс.** Модуль должен описывать интерфейс — методы и свойства — которые он может предоставить другим модулям.

**Импорт — не объявление**

Важно помнить, что импорт переменной не то же самое, что её объявление. При импорте переменная не создаётся, а честно импортируется, самая настоящая переменная из другого модуля. Такое поведение справедливо для всех видов импорта, которые мы разберём дальше (экспортировать как-то иначе тоже нельзя), поэтому будьте внимательны при работе с импортированными переменными. Ведь сложные типы данных, вроде объектов или массивов, при импорте передаются по ссылке, и их можно нечаянно испортить:

**Нюансы**

* **Код модуля выполняется целиком.** Если модуль импортирован, его код будет выполнен целиком независимо от способа импорта.
* **Только первый уровень.** import и export не могут быть вложены в функции или другие блоки кода:
* **Никакого поднятия** (hoisting). Импортированные переменные не поднимаются, поэтому import всегда должен быть в начале файла:
* **Путь — константа.** Путь в конструкции import является константой и не может быть сборным.

##Промисы
**Промис** — это глобальный объект Promise (с англ. «обещание»). Он позволяет отследить выполнение асинхронной операции и сохранить её результат. Сами асинхронные операции выполняются как и прежде: не сразу, а когда-нибудь. Промисы - это просто объект, позволяющий более эффективно работать с асинхронным кодом. Промисы - это способ борьбы с «адом колбеков». Промисы позволяют организовать асинхронный код по-другому: сделать его более плоским и последовательным, похожим на синхронный код.

**Ад колбэков** - это код на JavaScript, в котором используется много-много вложенных функций обратного вызова. Так много, что в таком коде трудно интуитивно разобраться.

**Особенности**

* Функция-исполнитель выполняется сразу.
* Промис может находиться в трёх состояниях.
* Нет возможности откатиться к предыдущему состоянию.

**Состояния промиса**

* pending — выполняется
* settled — завершён:
  * fulfilled — завершён успешно
  * rejected — завершён с ошибкой

**Методы**

* **then()** - этот метод передаёт результат.
* **catch()** - этот метод для обработки перехода промиса в состояние завершён с ошибкой.
* **finally()** - этот метод для выполнения функцию вне зависимости от того, завершился промис успешно или с ошибкой.
* **all()** - этот метод может пригодиться в ситуациях, когда требуется дождаться завершения нескольких промисов. Метод принимает в качестве единственного аргумента массив из промисов и возвращает новый промис, который будет завершён успешно, как только завершатся успешно все переданные в all() промисы. Если хоть один переданный в all() промис завершится с ошибкой, тогда и промис all() будет завершён с ошибкой.
* **race()** - этот метод не будет ждать завершения всех промисов, а дождётся завершения одного, который «придёт первым к финишу»
* **resolve()** - метод для проверки кода, который возвращает промис в состоянии завершён успешно.
* **reject()** - метод для проверки кода, который возвращает промис в состоянии завершён с ошибкой.

Методы then(), catch() и finally() всегда возвращают новый промис. За счёт этого появляется возможность строить цепочки вызовов промисов.

## Async/Await

В основе работы операторов async и await лежат промисы, просто эти операторы позволяют использовать промисы в другом синтаксисе. Их задача ещё больше упростить написание асинхронного кода и сделать его похожим (визуально!) на синхронный.

* **async** - этот оператор позволяет определить асинхронную функцию. Результатом выполнения такой функции всегда будет новый промис. async применяется при объявлении функций как декларативно, так и для функций-выражений.
* **await** - этот оператор позволяет дождаться выполнения промиса, за счёт чего достигается сходство с синхронным кодом. Иными словами оператор await вместе с оператором async образуют тандем, который как раз позволяет сделать асинхронный код похожим на синхронный.

При использовании async и await обрабатывать ошибки можно с помощью конструкции try...catch.

## JSON

JSON (JavaScript Object Notation) — открытый текстовый формат для обмена данными. Формат разработан Дугласом Крокфордом. Отличительная особенность формата — его легко интерпретировать не только машинам, но и людям.

Содержимое JSON — это коллекция из пар ключ/значение. Ключи определяются слева, а значение отделяется символом двоеточия (:).

**Структуры данных**

* коллекция из пар ключ/значение
* упорядоченный список значений

**Типы данных**

* строковые
* числовые
* булевы
* null

## Fetch API

**Fetch API** — современный, гибкий и универсальный способ для отправки запросов к серверу. Способ реализуется с помощью функции fetch(). В простых случаях можно обойтись буквально одной строчкой кода, а за счёт поддержки промисов обработка ответов также упрощается и превращается в последовательную цепочку.
Функция принимает два параметра: адрес ресурса, на который требуется отправить запрос, и объект с настройками, где переопределяем HTTP-метод (опционален). Результатом выполнения fetch() станет промис.

**Объект ответа (Response)** мы получаем при завершении промиса. В этом объекте хранится вся информация об ответе сервера: заголовки, статусы, результат выполнения запроса и другая служебная информация.

Определить успешность выполнения запроса поможет свойство объекта ответа ok. Оно содержит булево значение. Если запрос выполнен успешно, ok будет true. В противном случае false.

Звучит не сложно, но возникает другой вопрос: «А что подразумевается под успехом выполнения?» Успех определяется на основании кода ответа сервера на запрос. Если код ответа в диапазоне чисел 200-299, значит он выполнился успешно. Ответы с кодами, которые не попадают в диапазон, означают выполнение запроса с ошибкой.

## Типы данных

## Расширенные типы данных (TypedArray)

## Объекты и примитивы

## Виды функций (простые и стрелочные), IIFE

## .bind, .apply, .call

## Понимание замыканий

## Понимание асинхронности

## Синтаксис классов

## Работа с прототипами

## ES Modules

## Умение перенести CommonJS в ESM

## TypeScript

## Умение описывать типы

## Умение описывать сложные типы

## Умение работать с дженериками

## Умение мыслить типами

## Умение обновлять версию TS в проекте

## SPA: React, Vue, Angular

## SSR

## SSG

## Производительность и профилирование

## Умение работать со стейт менеджерами

## Data Access Layer (DAL)

## npm (pnpm, yarn)

## Знает чем отличается

## Как работает package-lock.json

## Умение разбирать конфликты зависимостей

## Умение выделить из проекта компонент для публикации

## уметь работать со сборкой

## Базовые знания как писать свой конфиг

## FrontOps

## Анализ и оптимизация бандлов

## Умение пользоваться Intl

## Работа с датами

## Понимание как развивается JavaScript

## Знание о движках и оптимизации под них
